import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.0";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
};

// Rate limiting store (in production, use Redis or similar)
const rateLimitStore = new Map<string, { count: number; resetTime: number }>();

const checkRateLimit = (userId: string, limit: number = 20, windowMs: number = 60000) => {
  const now = Date.now();
  const userLimit = rateLimitStore.get(userId);
  
  if (!userLimit || now > userLimit.resetTime) {
    rateLimitStore.set(userId, { count: 1, resetTime: now + windowMs });
    return true;
  }
  
  if (userLimit.count >= limit) {
    return false;
  }
  
  userLimit.count++;
  return true;
};

serve(async (req) => {
  console.log('Function called with method:', req.method);
  
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    console.log('Handling CORS preflight request');
    return new Response(null, { headers: corsHeaders });
  }

  try {
    // Authentication check (optional for testing)
    const authHeader = req.headers.get('authorization');
    let user = null;
    
    if (authHeader) {
      const supabase = createClient(
        Deno.env.get('SUPABASE_URL') ?? '',
        Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      );

      const token = authHeader.replace('Bearer ', '');
      const { data: { user: authUser }, error: userError } = await supabase.auth.getUser(token);
      
      if (!userError && authUser) {
        user = authUser;
        
        // Rate limiting for authenticated users
        if (!checkRateLimit(user.id, 20, 60000)) { // 20 requests per minute
          return new Response(JSON.stringify({ 
            success: false, 
            message: 'Rate limit exceeded. Please try again later.' 
          }), {
            status: 429,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          });
        }
      }
    }

    console.log('Processing request body...');
    const { text } = await req.json();
    console.log('Request data:', { textLength: text?.length, userId: user?.id || 'anonymous' });

    if (!text || text.trim().length === 0) {
      return new Response(
        JSON.stringify({
          success: false,
          message: 'Text input is required'
        }),
        {
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        }
      );
    }

    const openAIApiKey = Deno.env.get('OPENAI_API_KEY');
    console.log('OpenAI API key status:', openAIApiKey ? 'Available' : 'Not available');
    
    if (!openAIApiKey) {
      console.log('Using mock detection due to missing API key');
      // Return mock data if no API key
      const mockResult = generateMockDetection(text);
      return new Response(
        JSON.stringify({
          success: true,
          data: mockResult
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        }
      );
    }

    console.log('Analyzing text with OpenAI:', text.substring(0, 100) + '...');

    // Use OpenAI to analyze the text with timeout
    // Create timeout controller
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 25000); // 25 second timeout

    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${openAIApiKey}`,
          'Content-Type': 'application/json',
        },
        signal: controller.signal,
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            {
              role: 'system',
              content: `You are an AI detection expert. Analyze the given text and determine the probability that it was generated by AI. 
              
              Consider these factors:
              - Writing patterns and style consistency
              - Vocabulary usage and complexity
              - Sentence structure variations
              - Content depth and originality
              - Repetitive phrases or patterns
              
              Respond with a JSON object containing:
              - aiProbability: number between 0 and 1 (0 = definitely human, 1 = definitely AI)
              - confidenceLevel: "High", "Medium", or "Low"
              - analysis: detailed explanation of your reasoning
              - highlightedSegments: array of suspicious text segments with reasons`
            },
            {
              role: 'user',
              content: `Analyze this text for AI generation: "${text}"`
            }
          ],
          temperature: 0.3,
          response_format: { type: "json_object" }
        }),
      });
      
      clearTimeout(timeoutId);

      if (!response.ok) {
      console.error('OpenAI API error:', await response.text());
      const mockResult = generateMockDetection(text);
      return new Response(
        JSON.stringify({
          success: true,
          data: mockResult
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        }
      );
    }

    const result = await response.json();
    console.log('OpenAI response:', result);

    let analysis;
    try {
      analysis = JSON.parse(result.choices[0].message.content);
    } catch (e) {
      console.error('Error parsing OpenAI response:', e);
      analysis = generateMockDetection(text);
    }

    // Ensure we have the required fields
    const detectionResult = {
      aiProbability: analysis.aiProbability || 0.5,
      confidenceLevel: analysis.confidenceLevel || 'Medium',
      analysis: analysis.analysis || 'Analysis completed successfully.',
      highlightedSegments: analysis.highlightedSegments || [],
      textLength: text.length,
      timestamp: new Date().toISOString(),
      resultId: `result_${Date.now()}`
    };

    console.log('Final detection result:', detectionResult);

    return new Response(
      JSON.stringify({
        success: true,
        data: detectionResult
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    );

    } catch (fetchError) {
      clearTimeout(timeoutId);
      console.error('OpenAI API fetch error:', fetchError);
      // Return mock result on timeout or fetch error
      const mockResult = generateMockDetection(text);
      return new Response(
        JSON.stringify({
          success: true,
          data: mockResult
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        }
      );
    }

  } catch (error) {
    console.error('Error in detect-ai-text function:', error);
    return new Response(
      JSON.stringify({
        success: false,
        message: 'Failed to analyze text',
        error: error.message
      }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    );
  }
});

function generateMockDetection(text: string) {
  // Generate a pseudo-random probability based on text characteristics
  const textLength = text.length;
  const words = text.split(/\s+/).length;
  const avgWordLength = textLength / words;
  
  // Simple heuristics for mock detection
  let probability = 0.3; // Base probability
  
  // Longer texts with consistent patterns might be AI
  if (textLength > 500 && avgWordLength > 6) {
    probability += 0.2;
  }
  
  // Check for repetitive patterns
  const sentences = text.split(/[.!?]+/).filter(s => s.trim());
  if (sentences.length > 3) {
    const avgSentenceLength = sentences.reduce((sum, s) => sum + s.length, 0) / sentences.length;
    if (avgSentenceLength > 80) {
      probability += 0.15;
    }
  }
  
  // Add some randomness
  probability += (Math.random() - 0.5) * 0.3;
  probability = Math.max(0.1, Math.min(0.9, probability));
  
  let confidenceLevel = 'Medium';
  if (probability > 0.7 || probability < 0.3) {
    confidenceLevel = 'High';
  } else if (probability > 0.4 && probability < 0.6) {
    confidenceLevel = 'Low';
  }

  return {
    aiProbability: Math.round(probability * 100) / 100,
    confidenceLevel,
    analysis: `Text analysis shows ${Math.round(probability * 100)}% probability of AI generation. This assessment is based on writing patterns, sentence structure, and content characteristics. Note: This is a demonstration result.`,
    highlightedSegments: [],
    textLength: text.length,
    timestamp: new Date().toISOString(),
    resultId: `mock_${Date.now()}`
  };
}